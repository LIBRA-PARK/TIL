# 인 메모리 데이터베이스, Redis 와 Memcached 메모리 할당 비교

![Date](https://img.shields.io/badge/Date-2024--12--31-blue)
![Tag](https://img.shields.io/badge/Tag-Database-white)
---

## 인 메모리 데이터 베이스 란?

> 데이터를 일반적인 디스크(`HDD`, `SSD`)가 아닌 메모리(`RAM`)에 저장해 처리 속도를 상대적으로 매우 빠른 속도로 이루어지도록 구성한 데이터베이스

명칭 그대로 `In-memory` 데이터베이스는 메모리에 데이터를 저장하는 방식을 이용해 `Application`에서 접근에 필요한 계층을 줄여 상대적으로 매우 빠른 속도를 제공하도록 고안된 데이터베이스 입니다.
해당 구조적 특징으로 **월등한 데이터 처리 속도**를 보장할 수 있지만, 디스크에 비해서 **적은 메모리**와 RAM 계층이기에 **데이터가 휘발될 수 있다**는 단점이 공존 합니다. 

`In-memory`데이터베이스 영역에서는 `Memcached`와 `Redis`가 가장 많이 언급된다. 그렇다면 두 데이터베이스는 동일한 건가 생각해보면 둘의 차이는 생각보다 많으며, 그 중 메모리 할당에 중점적으로 설명해보고자 한다.

## Memcached

`Memcahced`는 `Redis`와 다르게 다양한 자료구조를 지원하거나 장애 대응을 위한 `Replication`등 편의 기능을 제공하지 않지만, `SLAB Allocator`를 이용한 메모리 관리로 `Redis`에 비해서 상대적으로 단편화를 최소화 활 수 있는 장점이 있습니다.
본 메모리 관리 방식으로 인해서 `Redis`에 비해서 안정적이면서 일관적인 성능을 발휘하지만, 고정 메모리 할당 바식으로 데이터의 유연성 확보가 어려워 다채로운 자료구조가 필요한 환경에서는 부적합한 단점을 가지고 있습니다.   

> 단편화(`Fragmentation`) : 메모리 공간이 비효율적으로 사용되어 실제로 사용될 수 있는 메모리 공간이 줄어드는 현상

> 복제(`Replication`) : 대표적으로 `Redis`의 `Master-Slave`구조로 장애 발생 시 데이터의 복사본을 다른 노드에 유지해 가용성을 확보하는 기술

- `SLAB Allocator` 이용해 `Redis`와 비교해 상대적으로 일관되고 안정적인 성능
- 멀티 스레드 환경을 기반하기에 `Scale-up`을 이용한 확장성 보장 
- 단순 자료구조를 지원하기에 단순 캐싱이나 데이터의 구조가 정적인 곳 다수 사용

### SLAB Allocator

주로, 커널에서 사용되는 메모리 할당 방식으로 특정 크기(주로 2의 거듭제곱, `64Byte`, `128byte` 등)로 구성된 **슬랩 클래스(=`slab cache`)** 를 고정된 메모리 영역을 생성 합니다.
그 후 해당 슬랩 클래스 내에서 동일한 크기의 **슬롯(=`Chunk`)** 을 만들어 두고, 데이터 저장 요청이 들어오게 되면 슬롯을 할당하거나 해제 하는 구조로 메모리를 관리합니다.
해당 방식을 사용할 경우 고정된 구조 내에서 메모리 할당이 이루어지기에 파편화 과정이 거의 발생하지 않도록 할 수 있지만, 구조적 문제로 다양한 크기로 분포된 데이터가 들어올 경우 새로운 슬랩 클래스를 만들거나 크기별 분산 관리가 어려운 단점이 있습니다.

#### 데어터 할당 예시
- 새로운 `100byte` 데이터 저장 하면, “`100byte`를 수용할 수 있는 가장 작은 슬랩 클래스를”를 찾음 (즉 `128byte` 슬랩 클래스)
- `128byte` 크기의 슬랩 클래스의 내부에 “비어 있는 슬롯” 있다면 해당 슬롯에 데이터를 저장.
- 슬롯 단위가 즉 고정된 메모리 영역이 남아있기 때문에, 내부 단편화가 상대적으로 적고 관리가 단순.

#### 구조적 특징
- 고정된 클래스 크기: 이미 크기별로 Slab Class가 정해져 있으므로, 해당 크기에 맞춰 빠르게 할당·해제를 수행
- 단편화 최소화: 같은 Slab Class에는 동일 크기의 청크만 들어가므로, 크기가 다른 데이터끼리 섞여서 생기는 외부 단편화가 거의 없음

## Redis

`SLAB Allocator`를 사용하는 `Memcached`와 달리 `Redis`는 `jemalloc` 메모리 할당 방식을 이용해서 상대적으로 유연한 메모리를 관리할 수 있는 이점이 있습니다. 해당 방식을 채용함으로써 보다 더 다양한 자료구조를 지원하는 장점이 있으나, 메모리 관리의 방식의 문제로 상대적으로 파편화가 다소 발생하게 됩니다.
따라서, `Memcahced`와 달리 특정 상황에서 성능이 튀는 현상을 발견할 수 있기도 합니다. 하지만, 장애가 발생할 경우 대응할 수 있는 `Replication`이나 영속성 관리할 수 있는 편의 기능을 제공하는 장점을 가지고 있습니다.

### jemalloc 과 Arena-Chunk-Run 구조

주로, 동적 메모리 할당 라이브러리로 사용되는 `jemalloc`은 멀티 스레드 환경에서 락 경쟁을 최소화하고, 다양한 크기의 메모리 요청을 처리하기 위해 `Arena-Chunk-Run` 구조를 사용합니다. 그 후, `Arena`는 운영체제(OS)로부터 수 MB 단위의 큰 메모리를 `Chunk`로 매핑받고, 해당 `Chunk`를 `Run`으로 세분화하여 **특정 사이즈(`bin`)** 의 객체만 저장하도록 구성합니다. 
해당 방식을 사용할 경우 다양한 크기의 메모리 요청을 효율적으로 처리할 수 있지만, 완전히 비어야 OS로 반납할 수 있는 Run 특성상 부분적 단편화가 발생할 수도 있습니다.

#### 데이터 할당 예시
- 새로운 `100byte` 데이터가 들어오면, `jemalloc`은 내부적으로 `100byte`를 수용할 수 있는 **사이즈 클래스(`bin`)** 를 찾습니다.
- 해당 `bin`을 담당하는 `Run`에서 비어 있는 슬롯이 있다면 그 슬롯을 사용합니다.
- 여러 `Arena`가 병렬로 동작하므로, 멀티 스레드 환경에서도 높은 처리량과 낮은 락 충돌을 기대할 수 있습니다.

#### 구조적 특징
- Arena 분산: 여러 Arena를 둠으로써 멀티 스레드에서 락 충돌을 줄이고, 병렬 할당 성능을 높임
- 다양한 크기(bin) 관리: Chunk를 여러 Run으로 쪼개고, 각 Run마다 특정 크기 객체만 저장해 빠른 할당/해제 가능
- 부분적 단편화: Run이 완전히 비워지지 않으면 OS 반납이 어려워 조각난 공간이 남을 수 있음

---
## Reference
- [Slab Memory Allocator 란?](https://jeongzero.oopy.io/132fed8f-5cfd-4f43-990c-61584744b4d0)
- [Session storage 적합한 데이터 베이스는 무엇일까? (Redis vs Memcached)](https://1-7171771.tistory.com/127)
- [Redis 와 Memcached](https://velog.io/@wlsgur1533/Redis와-MemCacahed)
- [In-memory Redis vs Memcached 비교하기](https://escapefromcoding.tistory.com/704)