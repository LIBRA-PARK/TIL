# 데이터베이스 락

![Date](https://img.shields.io/badge/Date-2024--12--24-blue)
![Tag](https://img.shields.io/badge/Tag-Database-white)
---

> 여러 트랜잭션이 동일한 데이터에 동시에 접근할 경우에 대한 일관성과 무결성을 보장하기 위해서 사용되는 것으로, 데이터베이스에 동시성을 제어하기 위한 요소

만약에 총 100개의 좌석으로 진행되는 연말 콘서트 예약 서비스를 구현한다고 가정해보자, 많은 사람들이 예약하기 위해서 동일한 데이터에 접근했다. 이때 해당 서비스가 데이터에 대한 무결성과 일관성을 보장하지 못한다면 102명이 예약되거나 110명이 예약되는 등 예기치 못한 상황이 발생할 것이다.

이런 문제를 방지하기 위해서 데이터베이스에서는 `lock` 을 이용해서 동시 접근에 대하여 제어하여 충돌을 방지한다.

## 역할
### 1. 데이터의 무결성 보장
> 만약 여러 트랜잭션이 동일한 데이터에 접근해 수정 또는 삭제할 경우 해당 데이터에 대한 일관성 및 무결성을 유지하도하는 역할을 한다.

- **예시**: 한 상품에 대한 재고를 관리하는 서비스가 있다고 가정하고 아래의 상황이 발생했다고 생각해보자
  1. **트랜잭션 A** 가 접근해서 상품 `id` 가 `product_a` 의 재고를 50에서 45로 수정함
     - `UPDATE prducts SET stock = 45 WHERE id = product_a;`
  2. **트랜잭션  B** 가 동일한 상품에 대한 재고를 50에서 40으로 수정하려고 함
     - `UPDATE prducts SET stock = 40 WHERE id = product_a;` 
  - **문제**: 만약 `lock` 없이 두 트랜잭션에 대한 순서를 보장할 수 없어 동시에 실행되어 결과에 대한 예상할 수 없음, 최종적으로 재고가 40이 될지 45가 될지 알 수 없음
 
**트랜잭션 A**에 `lock`을 걸어 **트랜잭션 B**가 대기할 수 있도록 한 후, **트랜잭션 A**가 완료된 후 **트랜잭션 B**가 실행되도록 보장합니다.

### 2. 동시성 제어
> 락은 여러 사용자가 동시에 데이터에 접근할 때, 데이터 충돌 없이 작업이 원활히 수행되도록 조율합니다.

- **예시**: **은행 계좌 관리**
    1. **트랜잭션 A**: 계좌 ID 1001에서 50,000원 인출.
        - `UPDATE accounts SET balance = balance - 50000 WHERE account_id = 1001;`
    2. **트랜잭션 B**: 계좌 ID 1001의 잔액 조회.
        - `SELECT balance FROM accounts WHERE account_id = 1001;`
    - **문제**: 락이 없으면 **트랜잭션 B**가 **트랜잭션 A**의 작업이 반영되기 전에 잔액을 조회해 잘못된 데이터를 반환.
  
**트랜잭션 A**에 `lock`을 걸어 **트랜잭션 B**가 대기할 수 있도록 하고, **트랜잭션 A**가 완료 후 커밋되면 **트랜잭션 B**가 정확한 데이터를 읽도록 합니다.

### 3. 트랜잭션 격리 수준 구현
> 락은 트랜잭션 격리 수준(READ UNCOMMITTED, READ COMMITTED, REPEATABLE READ, SERIALIZABLE)을 구현하는 데 필수적입니다.

- **예시**: **READ COMMITTED**
    1. **트랜잭션 A**: 주문 상태를 `Processing`으로 변경.
        - `UPDATE orders SET status = 'Processing' WHERE order_id = 5001;`
    2. **트랜잭션 B**: 주문 상태 조회.
        - `SELECT status FROM orders WHERE order_id = 5001;`
    - **문제**: 락이 없으면 **트랜잭션 B**가 **트랜잭션 A**의 커밋되지 않은 데이터를 읽어 **Dirty Read**가 발생.

**트랜잭션 A**에 `lock`을 걸어 **트랜잭션 B**는 대기 한 후, **트랜잭션 A**가 작업을 커밋한 후에만 **트랜잭션 B**가 데이터를 읽도록 합니다.

### 4. 경쟁 상태 방지
> 락은 동일 데이터를 동시에 수정하려는 여러 트랜잭션 간의 충돌을 방지합니다.

- **예시**: **영화 좌석 예약 시스템**
    1. **트랜잭션 A**: 좌석 ID 101 예약.
        - `UPDATE seats SET status = 'Reserved' WHERE seat_id = 101;`
    2. **트랜잭션 B**: 동일 좌석 ID 101 예약.
        - `UPDATE seats SET status = 'Reserved' WHERE seat_id = 101;`
    - **문제**: 락이 없으면 동일 좌석에 대해 이중 예약 발생 가능.

**트랜잭션 A**에 `lock`을 걸어 **트랜잭션 B**는 대기 한 후, **트랜잭션 A**가 완료되면 락이 해제되고, **트랜잭션 B**가 실행해 이중 예약되는 상황을 방지합니다.

| **락의 역할**       | **문제 해결**                                         | **예시**                                         |
|------------------|---------------------------------------------------|---------------------------------------------|
| 데이터 무결성 보장   | 데이터 수정 충돌 방지                                   | 상품 재고 관리, 중복 수정 방지                     |
| 동시성 제어       | 읽기-쓰기 충돌 방지, 데이터 정합성 유지                       | 은행 계좌 잔액 조회와 수정                        |
| 트랜잭션 격리 구현   | Dirty Read, Non-Repeatable Read 방지                | 주문 상태 변경 시 일관성 유지                      |
| 경쟁 상태 방지      | 동일 데이터의 중복 처리 방지                              | 영화 좌석 예약 시스템에서 이중 예약 방지              |
**결론적으로 `lock`은 데이터의 일관성과 무결성을 보장하며, 동시 작업 중 발생할 수 있는 충돌이나 데이터 손실을 방지합니다.**