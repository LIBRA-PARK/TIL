# 데이터베이스 락

![Date](https://img.shields.io/badge/Date-2024--12--24-blue)
![Tag](https://img.shields.io/badge/Tag-Database-white)
---

> 여러 트랜잭션이 동일한 데이터에 동시에 접근할 때 발생할 수 있는 **데이터 충돌, 무결성 훼손, 비일관성 문제를 방지**하고, 동시성을 안전하게 제어하기 위해 사용하는 데이터베이스의 핵심 메커니즘.

---
## 1. 락의 종류

### S-Lock (Shared Lock, 공유 락, 읽기 잠금)
- 데이터를 **읽는 작업(Read)** 동안 다른 트랜잭션이 **쓰기(Write)** 하지 못하도록 설정.
- 여러 트랜잭션이 동시에 데이터를 읽을 수 있음.
    - **락 해제**: 읽기 작업이 완료되면 락이 해제됨.
    - **예**: 트랜잭션 A가 데이터를 읽는 동안, 트랜잭션 B도 데이터를 읽을 수 있지만 수정은 불가능.

### X-Lock (Exclusive Lock, 배타 락, 쓰기 잠금)
- 데이터를 **수정하거나 삭제하는 작업(Write)** 동안 다른 트랜잭션이 해당 데이터에 접근하지 못하도록 설정.
- 데이터를 수정하는 동안 읽기와 쓰기 모두 제한.
    - **락 해제**: 수정 작업이 완료되고 커밋되면 락이 해제됨.
    - **예**: 트랜잭션 A가 데이터를 수정하는 동안, 트랜잭션 B는 읽기와 쓰기 모두 불가능.

---
## 역할
### 1. 데이터의 무결성 보장
> 여러 트랜잭션이 동일한 데이터에 접근해 수정 또는 삭제할 경우, 해당 데이터의 일관성 및 무결성을 유지하도록 하는 역할.

- **예시**: 한 상품의 재고를 관리하는 서비스
    1. **트랜잭션 A**가 접근해서 상품 `id`가 `product_a`의 재고를 50에서 45로 수정.
        - `UPDATE products SET stock = 45 WHERE id = product_a;`
    2. **트랜잭션 B**가 동일한 상품에 대한 재고를 50에서 40으로 수정하려고 시도.
        - `UPDATE products SET stock = 40 WHERE id = product_a;`

- **문제**:  
  만약 `X-Lock` 없이 두 트랜잭션이 동시에 실행되면 결과를 예측할 수 없음. 최종적으로 재고가 **45** 또는 **40** 중 무엇이 될지 알 수 없음.

- **해결**:  
  **트랜잭션 A**가 `X-Lock`을 걸어 **트랜잭션 B**가 대기하도록 한 후, **트랜잭션 A**가 완료된 후 **트랜잭션 B**가 실행되도록 보장해 최종 재고가 무엇이 될지 예측할 수 있도록 함

### 2. 동시성 제어
> 여러 사용자가 동시에 데이터를 읽거나 수정할 때, 데이터 충돌 없이 작업이 원활히 수행되도록 조율.

- **예시**: **은행 계좌 관리**
    1. **트랜잭션 A**: 계좌 ID 1001에서 50,000원 인출.
        - `UPDATE accounts SET balance = balance - 50000 WHERE account_id = 1001;`
    2. **트랜잭션 B**: 계좌 ID 1001의 잔액 조회.
        - `SELECT balance FROM accounts WHERE account_id = 1001;`

- **문제**:  
  락이 없으면 **트랜잭션 B**가 **트랜잭션 A**의 작업이 완료되기 전에 데이터를 읽어 잘못된 잔액을 반환.

- **해결**:  
  **트랜잭션 A**에 `X-Lock`을 걸어 **트랜잭션 B**는 대기 상태로 설정 해 **트랜잭션 A**가 작업을 커밋한 후에만 **트랜잭션 B**가 인출 된 후 정확한 잔액을 조회 할 수 있도록 보장.

### 3. 트랜잭션 격리 수준 구현
> 트랜잭션 격리 수준(READ UNCOMMITTED, READ COMMITTED, REPEATABLE READ, SERIALIZABLE)을 락으로 구현.

- **예시**: **READ COMMITTED**
    1. **트랜잭션 A**: 주문 상태를 `Processing`으로 변경.
        - `UPDATE orders SET status = 'Processing' WHERE order_id = 5001;`
    2. **트랜잭션 B**: 주문 상태를 조회.
        - `SELECT status FROM orders WHERE order_id = 5001;`

- **문제**:  
  락이 없으면 **트랜잭션 B**가 **트랜잭션 A**의 커밋되지 않은 데이터를 읽어 **Dirty Read** 발생.

- **해결**:  
  **트랜잭션 A**에 `X-Lock`을 걸어 커밋 완료 전까지 **트랜잭션 B**가 대기하도록 설정해, 변경된 상태를 조회할 수 있도록 보장 함

### 4. 경쟁 상태 방지
> 동일 데이터를 동시에 수정하려는 여러 트랜잭션 간의 충돌 방지.

- **예시**: **영화 좌석 예약**
    1. **트랜잭션 A**: 좌석 ID 101 예약.
        - `UPDATE seats SET status = 'Reserved' WHERE seat_id = 101;`
    2. **트랜잭션 B**: 동일 좌석 ID 101 예약.
        - `UPDATE seats SET status = 'Reserved' WHERE seat_id = 101;`

- **문제**:  
  락이 없으면 동일 좌석에 대해 이중 예약 발생 가능.

- **해결**:  
  **트랜잭션 A**가 `X-Lock`을 걸어 **트랜잭션 B**는 대기. **트랜잭션 A**가 완료되면 락이 해제되고, **트랜잭션 B**가 실행해 이중으로 예약되는 문제를 방지 함

| **락의 역할**       | **문제 해결**                                         | **예시**                                         |
|------------------|---------------------------------------------------|---------------------------------------------|
| 데이터 무결성 보장   | 데이터 수정 충돌 방지                                   | 상품 재고 관리, 중복 수정 방지                     |
| 동시성 제어       | 읽기-쓰기 충돌 방지, 데이터 정합성 유지                       | 은행 계좌 잔액 조회와 수정                        |
| 트랜잭션 격리 구현   | Dirty Read, Non-Repeatable Read 방지                | 주문 상태 변경 시 일관성 유지                      |
| 경쟁 상태 방지      | 동일 데이터의 중복 처리 방지                              | 영화 좌석 예약 시스템에서 이중 예약 방지              |
**결론적으로 `lock`은 데이터의 일관성과 무결성을 보장하며, 동시 작업 중 발생할 수 있는 충돌이나 데이터 손실을 방지합니다.**

## Reference
